# Data races
데이터 레이스는 동시성 프로그램을 작성할 때 발생하는 중요하고 기본적인 문제이다.
'데이터 레이스'는 두개의 분리된 스레드가 동시에 같은 mutable state에 접근할 때 발생한다. mutable state는 수정할 수 있는 데이터.
이 문제는 쉽게 생겨나지만 디버깅하기는 어렵다.

```swift
class Counter {
    var value = 0

    func increment() -> Int {
        value = value + 1
        return value
    }
}

let counter = Counter()

Task.detached {
    print(counter.increment()) // data race
}

Task.detached {
    print(counter.increment()) // data race
}
```
- 두개의 테스크가 동시에 increment() 함수를 같은 스레드에서 실행함. 실행되는 타이밍에 따라, 1과 2 또는 2와 1을 얻게되거나 1과 1, 심지어는 2와 2를 얻게 될 수도 있음.
- 데이터 레이스는 공유된 mutable state 때문에 발생함. 만약 데이터가 변경되지 않거나, 데이터가 동시에 발생하는 작업들에 공유되지 않는다면 데이터 레이스는 발생하지 않는다.
- 데이터 레이스를 피하는 방법 중 하나는 value semantics를 사용하여 공유되는 mutable state를 완전히 제거하는 것이다. 
- 시맨틱 값 타입의 let 프로퍼티는 변하지 않음으로 동시 작업들에서 접근하더라도 안전함. (Xcode가 변하지 않는 값에 let 속성을 사용하도록 추천하는 이유)

# Value Semantics
```swift
var array1 = [1, 2]
var array2 = array1

array1.append(3)
array2.append(4)

print(array1) // [1, 2, 3]
print(array2) // [1, 2, 4]
```
- array2는 array1의 복사본이기 때문에 초기화 후에 얻은 3, 4 는 각각의 배열에 append 됨.
- 위와 같이 배열과 같은 대부분의 스위프트 라이브러리의 타입들은 value semantics를 가짐. 

```swift
struct Counter {
    var value = 0    // <- *

    mutating func increment() -> Int {
        value = value + 1
        return value
    }
}

let counter = Counter()

Task.detached {
    var counter = counter
    print(counter.increment()) // always prints 1
}

Task.detached {
    var counter = counter
    print(counter.increment()) // always prints 1
}
```
- *: value-semantic 타입인 let 속성으로 변경할 수 없음. (increment() 함수에서 값을 변경 시킬 수 없음
- 대신 Counter를 각 concurrent task 속 로컬 mutable variable에 할당함


## What are actors?
- 공유된 mutable state를 동기화하는 메커니즘
- 하나의 actor는 자신만의 state를 가직고, 이 state는 프로그램의 나머지 부분과 분리됨. 이 state에 접근하는 유일한 방법은 해당 actor를 통하는 방법 밖에 없음.
- actor를 통해 변수에 접근하는 동안, actor의 동기화 메커니즘은 다른 코드가 해당 state에 접근하지 못하도록 함.
- actor는 새로운 종류의 타입이다. 스위프트의 모든 타입들의 기능을 가지고 있다.
- 클래스처럼 reference type이다. (value types는 애초에 actor가 필요하지 않음)
- 액터 타입이 다른 타입들과 구분되는 가장 큰 특징은 자신의 인스턴스를 프로그램의 나머지 부분으로부터 격리시키고 그 데이터에 대한 동기화된 접근을 보장한다는 것.
- 아래 정의된 actor 타입 클래스인 Counter는 위 예시 코드에 정의된 Counter 클래스와 똑같이 인스턴스 프로퍼티인 value와 increment 메서드를 가지고 있지만, actor 클래스의 value는 
```swift
// actor 타입으로 정의한 카운터 클래스
actor Counter {
    var value = 0

    func increment() -> Int {
        value = value + 1
        return value
    }
}

let counter = Counter()

Task.detached {
    print(await counter.increment())
}

Task.detached {
    print(await counter.increment())
}
```

## How Actors are utilizied to protect mutable state
